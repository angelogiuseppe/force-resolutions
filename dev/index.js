#!/usr/bin/env node

"use strict"; var e = require("fs"), n = require("path"); function t(e, n, t, o) { return new (t || (t = Promise))((function (i, r) { function s(e) { try { l(o.next(e)) } catch (e) { r(e) } } function c(e) { try { l(o.throw(e)) } catch (e) { r(e) } } function l(e) { var n; e.done ? i(e.value) : (n = e.value, n instanceof t ? n : new t((function (e) { e(n) }))).then(s, c) } l((o = o.apply(e, n || [])).next()) })) } "function" == typeof SuppressedError && SuppressedError; const o = n => t(void 0, void 0, void 0, (function* () { try { return yield e.promises.access(n, e.constants.O_RDWR), !0 } catch (e) { return !1 } })); let i, r, s, c, l = !0; "undefined" != typeof process && (({ FORCE_COLOR: i, NODE_DISABLE_COLORS: r, NO_COLOR: s, TERM: c } = process.env || {}), l = process.stdout && process.stdout.isTTY); const d = { enabled: !r && null == s && "dumb" !== c && (null != i && "0" !== i || l), reset: u(0, 0), bold: u(1, 22), dim: u(2, 22), italic: u(3, 23), underline: u(4, 24), inverse: u(7, 27), hidden: u(8, 28), strikethrough: u(9, 29), black: u(30, 39), red: u(31, 39), green: u(32, 39), yellow: u(33, 39), blue: u(34, 39), magenta: u(35, 39), cyan: u(36, 39), white: u(37, 39), gray: u(90, 39), grey: u(90, 39), bgBlack: u(40, 49), bgRed: u(41, 49), bgGreen: u(42, 49), bgYellow: u(43, 49), bgBlue: u(44, 49), bgMagenta: u(45, 49), bgCyan: u(46, 49), bgWhite: u(47, 49) }; function a(e, n) { let t, o = 0, i = "", r = ""; for (; o < e.length; o++)t = e[o], i += t.open, r += t.close, ~n.indexOf(t.close) && (n = n.replace(t.rgx, t.close + t.open)); return i + n + r } function u(e, n) { let t = { open: `[${e}m`, close: `[${n}m`, rgx: new RegExp(`\\x1b\\[${n}m`, "g") }; return function (n) { return void 0 !== this && void 0 !== this.has ? (~this.has.indexOf(e) || (this.has.push(e), this.keys.push(t)), void 0 === n ? this : d.enabled ? a(this.keys, n + "") : n + "") : void 0 === n ? function (e, n) { let t = { has: e, keys: n }; return t.reset = d.reset.bind(t), t.bold = d.bold.bind(t), t.dim = d.dim.bind(t), t.italic = d.italic.bind(t), t.underline = d.underline.bind(t), t.inverse = d.inverse.bind(t), t.hidden = d.hidden.bind(t), t.strikethrough = d.strikethrough.bind(t), t.black = d.black.bind(t), t.red = d.red.bind(t), t.green = d.green.bind(t), t.yellow = d.yellow.bind(t), t.blue = d.blue.bind(t), t.magenta = d.magenta.bind(t), t.cyan = d.cyan.bind(t), t.white = d.white.bind(t), t.gray = d.gray.bind(t), t.grey = d.grey.bind(t), t.bgBlack = d.bgBlack.bind(t), t.bgRed = d.bgRed.bind(t), t.bgGreen = d.bgGreen.bind(t), t.bgYellow = d.bgYellow.bind(t), t.bgBlue = d.bgBlue.bind(t), t.bgMagenta = d.bgMagenta.bind(t), t.bgCyan = d.bgCyan.bind(t), t.bgWhite = d.bgWhite.bind(t), t }([e], [t]) : d.enabled ? a([t], n + "") : n + "" } } function b(e, n) { return e === n[0] && n.length > 1 } function g(e, n) { const t = n.indexOf(e); return t > 0 && t + 1 < n.length } const h = (e, n, t = new Map) => "object" != typeof n ? (t.set(e, n), t) : Object.entries(n).reduce(((n, [t, o]) => (n.set(e.concat(t), o), n)), t); function p(e, n) { const { hasOwnProperty: t } = Object.prototype; return n.reduce(((e, n) => e && t.call(e, n) ? e[n] : void 0), e) } (function () { return t(this, void 0, void 0, (function* () { try { const t = process.cwd(), i = n.join(t, "package-lock.json"), r = n.join(t, "package.json"), [s, c] = yield Promise.all([i, r].map(o)); if (s && c) { const [n, t] = yield Promise.all([i, r].map((n => e.promises.readFile(n)))); let o = JSON.parse(t.toString()), s = JSON.parse(n.toString()); const { resolutions: c } = o; console.log(d.cyan("Applying forced resolutions:")); let l = 0; const a = e => { let n = l; for (const [n, t] of e.entries()) p(s, n) !== t && (l += 1); return l > n }; c && (Object.keys(c).forEach((e => { const n = function (e, n) { const t = [{ path: [], object: e }], o = new WeakSet, i = []; for (; t.length > 0;) { const { object: e, path: s } = t.shift(); (r = e) && "object" == typeof r && !o.has(e) && (o.add(e), Object.entries(e).forEach((([e, o]) => { e === n && i.push([...s, e]), t.push({ path: [...s, e], object: o }) }))) } var r; return i }(s, e); if (n.length < 1) return; const t = new Map; if (n.forEach((n => { !g("dependencies", n) || g("required", n) || b("packages", n) ? b("packages", n) ? h(n, c[e], t) : g("requires", n) && (h(n, c[e], t), h(n.map((e => "requires" === e ? "dependencies" : e)), { version: c[e], resolved: void 0, integrity: void 0, requires: void 0 }, t)) : h(n, { version: c[e], resolved: void 0, integrity: void 0, requires: void 0 }, t) })), a(t)) { s = ((e, n) => { for (const [t, o] of n.entries()) { const n = t[t.length - 1], i = t.slice(0, t.length - 1).reduce(((e, n) => ("object" != typeof (null == e ? void 0 : e[n]) && Object.assign(e, { [n]: {} }), e[n])), e); Object.assign(i, { [n]: o }) } return e })(s, t); const n = c[e]; console.log(d.dim(`${e} => ${n}`)) } })), l > 0 ? (yield e.promises.writeFile(i, JSON.stringify(s, null, 2)), console.log(d.green("Finished applying forced resolutions."))) : console.log(d.green("All resolutions already up-to-date."))) } else s || console.log(d.grey("package-lock.json not found - can not force resolutions (try to execute `npm install` command before).")) } catch (e) { console.log(d.red("An unexpected error has occurred while running force-resolutions.")), console.error(e) } })) })().then();
